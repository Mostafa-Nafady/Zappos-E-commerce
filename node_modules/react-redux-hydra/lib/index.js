'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addReducer = exports.flushQueue = exports.assignmentGroup = exports.isAssigned = undefined;

var _reducer = require('./reducer');

var _reducer2 = _interopRequireDefault(_reducer);

var _middleware = require('./middleware');

var _abState = require('./abState');

var _zfc = require('./zfc');

var _hydra = require('./hydra');

var _config = require('./config');

var _actions = require('./actions');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Check if the user has been assigned to the given group for the given test,
 * and the test is active.
 *
 * @param {string} name - name of the a/b test
 * @param {number} index - index of the test group
 * @param {Object} state - application state
 * @return {boolean} inGroup - true/false if the user is in the group
 */
var isAssigned = exports.isAssigned = function isAssigned(name, index, state) {
  return (0, _abState.activeAssignedIndex)(name, state) === index;
};

/**
 * Get an active assignments group
 *
 * @param {string} name - name of the a/b test
 * @param {Object} state - application state
 * @return {integer} group number
 */

var assignmentGroup = exports.assignmentGroup = function assignmentGroup(name, state) {
  return (0, _abState.activeAssignedIndex)(name, state);
};

/**
 * Flush the assignment queue. This handles notifying zfc about any server-side
 * assignments. It's meant to be called at some point BEFORE passing the initial
 * state off to the redux store. It returns a new state with the queue cleared.
 * @param {Object} state - old state with queue
 * @param {Object} win - window
 * @return {Object} state - new state with cleared queue
 */
var flushQueue = exports.flushQueue = function flushQueue(state) {
  var win = arguments.length <= 1 || arguments[1] === undefined ? window : arguments[1];

  var queue = (0, _abState.getQueue)(state);
  if (queue && queue.length > 0) {
    queue.forEach(function (_ref) {
      var name = _ref.name;
      var treatment = _ref.treatment;
      var index = _ref.index;
      var lastIndex = _ref.lastIndex;

      (0, _zfc.zfcRecordTest)(name, treatment, index, lastIndex, win);
    });
    (0, _zfc.zfcSendEvent)(win);
    return (0, _abState.clearQueue)(state);
  }
  return state;
};

/**
 * Add the reducer to the object, using the appropriate key
 * @param {Object} reducers - object of all reducers
 * @param {Object} newReducers - reducers with ab reducer added
 */
var addReducer = exports.addReducer = function addReducer(reducersObj) {
  return Object.assign({}, reducersObj, { ab: _reducer2.default });
};

var hydra = {
  fetchActiveTests: _hydra.fetchActiveTests
};

var config = {
  setConfig: _config.setConfig,
  getConfig: _config.getConfig
};

var actions = {
  forceAssignment: _actions.forceAssignment,
  fetchCookieAssignments: _actions.fetchCookieAssignments,
  receiveActiveTests: _actions.receiveActiveTests,
  receiveActiveTestsAndSyncCookie: _actions.receiveActiveTestsAndSyncCookie,
  triggerAssignment: _actions.triggerAssignment,
  triggerAssignmentFactory: _actions.triggerAssignmentFactory
};

var middleware = {
  checkActiveHydraTestsFactory: _middleware.checkActiveHydraTestsFactory
};

exports.default = {
  actions: actions,
  config: config,
  hydra: hydra,
  middleware: middleware,
  addReducer: addReducer,
  flushQueue: flushQueue,
  isAssigned: isAssigned,
  assignmentGroup: assignmentGroup,
  plugToRequest: _zfc.plugToRequest,
  zfcSessionId: _zfc.zfcSessionId
};